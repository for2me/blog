<!-- intro: JavaScript Event Loop 是 JavaScript 运行时的一个重要概念，它控制着 JavaScript 代码的执行顺序。 Event Loop 是一个持续不断循环执行的过程，它会检查 JavaScript 引擎内部的任务队列，如果队列中有任务，就会依次执行这些任务。当队列为空时，Event Loop 就会等待新的任务加入队列。  -->

## 关于事件循环（Event Loop）的理解



> JavaScript Event Loop 是 JavaScript 运行时的一个重要概念，它控制(保证)着 JavaScript 代码的执行顺序。 Event Loop 是一个持续不断循环执行的过程，它会检查 JavaScript 引擎内部的任务队列，如果队列中有任务，就会依次执行这些任务。当队列为空时，Event Loop 就会等待新的任务加入队列。 



事件循环主要分为两个阶段：`执行栈`和`任务队列`。所有`同步任务`都在主线程上执行，形成一个`执行栈`。`执行栈`是一个存储函数调用的栈。当 JavaScript 引擎执行函数时，它会将函数放入`执行栈`中。当函数执行完毕时，它就会从栈中弹出。而`任务队列`则是一个用来存储待执行任务的队列，它包含了一些由异步操作（例如，定时器、网络请求、事件处理等）产生的任务。当这些**异步操作**完成后，它们会被添加到`任务队列`中，等待 JavaScript 引擎执行。

```js
console.log(1); 

setTimeout(()=>{ console.log(2) },1000);

console.log(3); 
```
很经典也很简单的代码，不难理解上方代码的输出结果依次为 1、3、2，setTimeout()将第二行推迟到1000毫秒之后执行。因为 js 先把`执行栈`里打印 1 和 3 的语句执行完毕(同步任务)，把定时器事件放入`任务队列`，最后执行。
 
```js
setTimeout(()=>{console.log(1)}, 0);

console.log(2);
```
即使将`setTimeout`的第二个参数设为0，上面代码的执行结果也总是2，1。因为只有在执行完第二行以后，系统才会去执行`任务队列`中的回调函数。


**因此，可以理解 `事件循环` 就是先将`执行栈`中的事件执行完成后再执行`任务队列`中事件 由此不断循环**


 ---

**而随着 ES6 中 `Promise` 的出现，`任务队列`被划分为更加细致的`微任务队列`与`宏任务队列`**

总结一下即异步任务分为 `宏任务` 与 `微任务`。 `宏任务`会进入`宏任务队列`，而微任务会进入`微任务队列`。**微任务要优于宏任务执行**
 
 
常见的宏任务和微任务
>宏任务：script(整体代码)、setTimeout、setInterval、I/O、事件、postMessage、 MessageChannel、setImmediate (Node.js)
微任务：Promise.then、 MutaionObserver、process.nextTick(Node.js)

```js
console.log('1')

setTimeout(function() {
   Promise.resolve().then(() => {
     console.log('2')
   })
   console.log('3')
}, 0)

new Promise(resolve => {
   console.log('4')
   resolve()
   setTimeout(() => console.log('5'), 0)
}).then(function() {
   console.log('6')
})

console.log('7')
```
根据理解可以解上面的题：
#### 1. 先执行`执行栈`中的`同步任务`
  - 遇到 `console.log('1')` 直接执行打印 1
  - 遇到 setTimeout 将回调函数放入`宏任务队列`
  - 进入 Promise(回调函数立即执行) 遇到 `console.log('4')` 直接执行打印 4
  - 遇到 resolve 将 Promise 对象的状态设置为 fulfilled。 
  - 遇到 setTimeout 将回调函数放入`宏任务队列`
  - 执行 then() 方法，创建一个新的 Promise 对象，将回调函数放入`微任务队列` 
  - 遇到 `console.log('7')` 直接执行打印 7
  > 此时第一轮执行结束 打印 1， 4 ，7。宏任务队列有两个任务。微任务队列有一个任务。 
  **微任务优于宏任务执行接下来执行微任务队列**

#### 2. 接下来执行`微任务队列` 
  - 进入`微任务队列` 遇到 `console.log('6')` 直接执行打印 6 
  > 此时`微任务队列`执行结束。宏任务队列有两个任务。微任务队列没有任务。

#### 3. 接下来执行宏任务队列 
  - 进入`宏任务队列`遇到 `Promise.resolve().then` 将回调函数放入`微任务队列`
  - 遇到`console.log('3')` 直接执行打印 3
  > 此时 宏任务队列剩下一个任务。微任务队列有一个任务。
     **微任务优于宏任务执行接下来执行微任务队列**

#### 4. 接下来执行`微任务队列`  
  - 进入微任务队列 遇到 `console.log('2')` 直接执行打印 2
  > 此时`微任务队列`执行结束。宏任务队列有一个任务。微任务队列没有任务
 
####  5. 接下来执行`宏任务队列`  
  - 进入宏任务队列 遇到 `console.log('5')` 直接执行打印 5

**全部执行完毕。打印顺序：1， 4， 7， 6，3，2，5**


---
Event Loop 的工作流程：  
  - JavaScript 引擎执行当前的同步代码，并将相应的函数调用添加到执行栈中，依次执行这些函数。  
  - 当 JavaScript 引擎遇到一个异步操作时，它会将该操作添加到任务队列中，并继续执行后续的同步代码。  
  - 当执行栈中的所有函数执行完毕时，JavaScript 引擎会检查任务队列中是否有待执行的任务。如果有，它会将队列中的第一个任务添加到执行栈中，并执行该任务对应的函数。  
  - JavaScript 引擎重复上述步骤，直到任务队列为空  

---
再简单总结即   
  - 先执行`同步任务`再执行`异步任务`中的回调。  
  - `异步任务`又分为 `宏任务` 与 `微任务`。  
  - 先执行`微任务`再执行`宏任务`。
  - 以上不断循环♻️
 
 ---
 
 Nice 我理解就这样了 等发现有啥错再改







 




 